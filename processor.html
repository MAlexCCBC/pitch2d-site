<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pitch2D | Analysis Console</title>
    <meta name="description" content="Professional Football Video Analysis Dashboard">
    
    <!-- Libraries -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.11.0"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd@2.2.3"></script>
    
    <!-- Fonts & Icons -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700;800&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        :root {
            --primary: #00d4ff;
            --secondary: #00ff88;
            --bg-dark: #0a1828;
            --bg-darker: #050c14;
            --glass: rgba(255, 255, 255, 0.03);
            --glass-border: rgba(255, 255, 255, 0.1);
            --text-main: #ffffff;
            --text-muted: #94a3b8;
            --pitch-grass: #1a472a;
            --pitch-line: rgba(255,255,255,0.6);
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-dark);
            background-image: 
                radial-gradient(at 0% 0%, rgba(0, 212, 255, 0.1) 0px, transparent 50%),
                linear-gradient(135deg, #0a1828 0%, #1a2332 100%);
            color: var(--text-main);
            min-height: 100vh;
        }

        /* Grid Background */
        .grid-bg {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 40px 40px;
            pointer-events: none;
            z-index: -1;
        }

        /* Navbar */
        .navbar {
            position: fixed; top: 0; width: 100%;
            background: rgba(10, 24, 40, 0.9);
            backdrop-filter: blur(12px);
            padding: 1rem 2rem;
            display: flex; justify-content: space-between; align-items: center;
            z-index: 1000;
            border-bottom: 1px solid var(--glass-border);
        }

        .logo-container {
            display: flex; align-items: center; gap: 0.8rem;
            text-decoration: none; cursor: pointer;
        }

        .logo-text {
            font-size: 1.5rem; font-weight: 800;
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }

        .nav-btn {
            padding: 0.5rem 1.2rem;
            background: transparent;
            border: 1px solid var(--primary);
            color: var(--primary);
            border-radius: 50px;
            text-decoration: none;
            font-size: 0.9rem; font-weight: 600;
            transition: all 0.3s ease;
        }

        .nav-btn:hover { background: var(--primary); color: var(--bg-dark); }

        /* Main Container */
        .container {
            max-width: 1600px; margin: 6rem auto 2rem; padding: 2rem;
        }

        /* Upload Section */
        .upload-section {
            background: var(--glass);
            border: 2px dashed var(--glass-border);
            border-radius: 20px;
            padding: 5rem 2rem;
            text-align: center;
            transition: all 0.3s ease;
            max-width: 800px; margin: 0 auto;
        }

        .upload-section.dragover {
            background: rgba(0, 212, 255, 0.05);
            border-color: var(--secondary);
            transform: scale(1.01);
        }

        .upload-icon {
            font-size: 4rem; color: var(--primary); margin-bottom: 1.5rem;
        }

        .file-label {
            display: inline-block;
            padding: 1rem 2.5rem;
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            color: var(--bg-dark);
            font-weight: 700;
            border-radius: 50px;
            cursor: pointer;
            transition: transform 0.2s;
            margin-top: 1.5rem;
        }

        .file-label:hover { transform: translateY(-2px); }
        input[type="file"] { display: none; }

        /* Processing UI */
        .processing-panel {
            display: none;
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 3rem;
            max-width: 800px; margin: 0 auto;
            text-align: center;
        }

        .progress-bar-container {
            width: 100%; height: 10px;
            background: rgba(255,255,255,0.1);
            border-radius: 10px;
            overflow: hidden;
            margin: 2rem 0;
        }

        .progress-bar {
            height: 100%; width: 0%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            transition: width 0.3s ease;
        }

        .log-console {
            text-align: left;
            background: rgba(0,0,0,0.3);
            padding: 1rem;
            border-radius: 10px;
            height: 150px;
            overflow-y: auto;
            font-family: monospace;
            font-size: 0.85rem;
            color: var(--text-muted);
            border: 1px solid var(--glass-border);
        }

        .log-entry.info { color: var(--primary); }
        .log-entry.success { color: var(--secondary); }
        .log-entry.error { color: #ff4444; }

        /* Dashboard / Results */
        .dashboard {
            display: none;
            grid-template-columns: 1.2fr 1fr;
            gap: 2rem;
            height: 80vh;
        }

        .panel {
            background: var(--glass);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 1.5rem;
            display: flex; flex-direction: column;
            backdrop-filter: blur(10px);
        }

        .panel-header {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: 1rem;
            padding-bottom: 1rem;
            border-bottom: 1px solid var(--glass-border);
        }

        .video-container, .canvas-container {
            flex: 1;
            position: relative;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            display: flex; align-items: center; justify-content: center;
        }

        video, canvas {
            max-width: 100%; max-height: 100%;
            border-radius: 8px;
        }

        .stats-row {
            display: grid; grid-template-columns: repeat(3, 1fr); gap: 1rem;
            margin-top: 1rem;
        }

        .stat-box {
            background: rgba(255,255,255,0.05);
            padding: 1rem;
            border-radius: 10px;
            text-align: center;
        }

        .stat-val { font-size: 1.5rem; font-weight: 700; color: var(--secondary); }
        .stat-lbl { font-size: 0.8rem; color: var(--text-muted); }

        .controls {
            display: flex; gap: 1rem; justify-content: center; margin-top: 1rem;
        }

        .ctrl-btn {
            background: rgba(255,255,255,0.1);
            border: none; color: #fff;
            padding: 0.8rem 1.5rem;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .ctrl-btn:hover { background: rgba(255,255,255,0.2); }
        .ctrl-btn.action { background: var(--primary); color: var(--bg-dark); font-weight: 700; }
        .ctrl-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* Responsive */
        @media (max-width: 1024px) {
            .dashboard { grid-template-columns: 1fr; height: auto; }
            .container { padding: 1rem; margin-top: 5rem; }
        }
    </style>
</head>
<body>

    <div class="grid-bg"></div>

    <nav class="navbar">
        <div class="logo-container" onclick="window.location.href='index.html'">
            <svg width="30" height="30" viewBox="0 0 100 100">
                <defs>
                    <linearGradient id="navLogoGrad" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#00d4ff;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#00ff88;stop-opacity:1" />
                    </linearGradient>
                </defs>
                <circle cx="50" cy="50" r="45" fill="none" stroke="url(#navLogoGrad)" stroke-width="4"/>
                <rect x="30" y="30" width="40" height="40" fill="none" stroke="url(#navLogoGrad)" stroke-width="3"/>
            </svg>
            <span class="logo-text">Pitch2D</span>
        </div>
        <a href="index.html" class="nav-btn">Back Home</a>
    </nav>

    <div class="container">
        
        <!-- 1. UPLOAD -->
        <div id="uploadSection" class="upload-section">
            <i class="fas fa-cloud-upload-alt upload-icon"></i>
            <h2 style="font-size: 2rem; margin-bottom: 1rem;">Analyze Match Footage</h2>
            <p style="color: var(--text-muted); margin-bottom: 2rem;">Drag & drop MP4, AVI, or WebM video (Max 200MB)</p>
            <label for="videoFile" class="file-label">Select Video File</label>
            <input type="file" id="videoFile" accept="video/*">
        </div>

        <!-- 2. PROCESSING -->
        <div id="processingSection" class="processing-panel">
            <div class="spinner" style="font-size: 2rem; margin-bottom: 1rem;">⚙️</div>
            <h2 id="statusTitle">Initializing Engine...</h2>
            <div class="progress-bar-container">
                <div id="progressBar" class="progress-bar"></div>
            </div>
            <div id="logConsole" class="log-console"></div>
        </div>

        <!-- 3. DASHBOARD -->
        <div id="dashboard" class="dashboard">
            <!-- Left: Original Video -->
            <div class="panel">
                <div class="panel-header">
                    <h3><i class="fas fa-video"></i> Input Source</h3>
                    <span class="stat-lbl" id="videoRes">1920x1080</span>
                </div>
                <div class="video-container">
                    <video id="mainVideo" playsinline style="width: 100%;"></video>
                </div>
                <div class="controls">
                    <button class="ctrl-btn" id="btnPlay"><i class="fas fa-play"></i></button>
                    <button class="ctrl-btn" id="btnPause"><i class="fas fa-pause"></i></button>
                    <button class="ctrl-btn" id="btnReset"><i class="fas fa-undo"></i></button>
                </div>
            </div>

            <!-- Right: 2D Map -->
            <div class="panel">
                <div class="panel-header">
                    <h3><i class="fas fa-map"></i> Tactical View</h3>
                    <button class="ctrl-btn action" id="btnDownload" disabled>Download</button>
                </div>
                <div class="canvas-container">
                    <canvas id="pitchCanvas" width="800" height="550"></canvas>
                </div>
                
                <div class="stats-row">
                    <div class="stat-box">
                        <div class="stat-val" id="statPlayers">0</div>
                        <div class="stat-lbl">Players</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-val" id="statConf">0%</div>
                        <div class="stat-lbl">Confidence</div>
                    </div>
                    <div class="stat-box">
                        <div class="stat-val" id="statTime">0s</div>
                        <div class="stat-lbl">Time</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden Canvas for processing -->
    <canvas id="processCanvas" style="display: none;"></canvas>

    <script>
        /**
         * Pitch2D Core Logic
         * Handles: Video Processing, TensorFlow Detection, Color Extraction, 2D Mapping
         */

        // Configuration
        const CONFIG = {
            DETECTION_INTERVAL: 3, // Process every Nth frame to save performance
            CONFIDENCE_THRESHOLD: 0.55, // Ignore low confidence detections
            PITCH_COLOR: '#1a472a',
            LINE_COLOR: 'rgba(255,255,255,0.7)',
            TEAM_A_COLOR: '#3b82f6', // Blue
            TEAM_B_COLOR: '#ef4444', // Red
            REF_COLOR: '#fbbf24',    // Yellow/Orange
            BALL_COLOR: '#ffffff'
        };

        // State
        let state = {
            videoFile: null,
            model: null,
            analysisData: [], // Stores frame-by-frame data
            isProcessing: false,
            videoDuration: 0,
            processingStartTime: 0
        };

        // Elements
        const els = {
            upload: document.getElementById('uploadSection'),
            process: document.getElementById('processingSection'),
            dashboard: document.getElementById('dashboard'),
            video: document.getElementById('mainVideo'),
            canvas: document.getElementById('pitchCanvas'),
            ctx: document.getElementById('pitchCanvas').getContext('2d'),
            hiddenCanvas: document.getElementById('processCanvas'),
            hiddenCtx: document.getElementById('processCanvas').getContext('2d', { willReadFrequently: true }),
            logs: document.getElementById('logConsole'),
            progress: document.getElementById('progressBar'),
            fileInput: document.getElementById('videoFile')
        };

        // --- Event Listeners ---

        els.fileInput.addEventListener('change', (e) => handleFile(e.target.files[0]));
        
        els.upload.addEventListener('dragover', (e) => {
            e.preventDefault();
            els.upload.classList.add('dragover');
        });
        
        els.upload.addEventListener('drop', (e) => {
            e.preventDefault();
            els.upload.classList.remove('dragover');
            if(e.dataTransfer.files.length) handleFile(e.dataTransfer.files[0]);
        });

        document.getElementById('btnPlay').onclick = () => els.video.play();
        document.getElementById('btnPause').onclick = () => els.video.pause();
        document.getElementById('btnReset').onclick = () => { els.video.currentTime = 0; els.video.pause(); drawPitch(); };
        
        document.getElementById('btnDownload').onclick = downloadVideo;

        // --- Core Functions ---

        function handleFile(file) {
            if(!file || !file.type.startsWith('video/')) {
                alert('Please upload a valid video file.');
                return;
            }
            state.videoFile = file;
            startWorkflow();
        }

        async function startWorkflow() {
            // UI Switch
            els.upload.style.display = 'none';
            els.process.style.display = 'block';
            state.processingStartTime = Date.now();

            log('Initializing System...', 'info');

            try {
                // 1. Load Model
                log('Loading COCO-SSD AI Model (this may take a moment)...', 'info');
                state.model = await cocoSsd.load();
                log('AI Model Loaded Successfully', 'success');
                updateProgress(10);

                // 2. Load Video Data
                const videoUrl = URL.createObjectURL(state.videoFile);
                els.video.src = videoUrl;
                
                await new Promise(resolve => els.video.onloadedmetadata = resolve);
                state.videoDuration = els.video.duration;
                
                log(`Video Info: ${els.video.videoWidth}x${els.video.videoHeight}, ${state.videoDuration.toFixed(1)}s`, 'info');
                document.getElementById('videoRes').textContent = `${els.video.videoWidth}x${els.video.videoHeight}`;

                // 3. Start Frame Analysis
                await processVideoFrames();

            } catch (err) {
                log(`Error: ${err.message}`, 'error');
                console.error(err);
                alert('An error occurred during processing. Check console.');
            }
        }

        async function processVideoFrames() {
            const width = els.video.videoWidth;
            const height = els.video.videoHeight;
            
            // Resize hidden canvas to match video for accurate detection
            els.hiddenCanvas.width = width;
            els.hiddenCanvas.height = height;

            // We process detection at a lower resolution for speed, but map back to full
            // Actually, for COCO-SSD in browser, let's use native video size but skip frames.
            
            const fps = 30; // Assumed
            const totalFrames = Math.floor(state.videoDuration * fps);
            let currentFrameIdx = 0;
            let currentTime = 0;

            log('Starting Frame-by-Frame Analysis...', 'info');

            // Mute video during processing seek
            els.video.muted = true;

            while (currentTime < state.videoDuration) {
                // Seek to time
                els.video.currentTime = currentTime;
                await new Promise(r => els.video.onseeked = r);

                // Draw to hidden canvas
                els.hiddenCtx.drawImage(els.video, 0, 0, width, height);

                // Perform Detection
                // Memory Management: Clean up tensors
                tf.engine().startScope();
                const detections = await state.model.detect(els.hiddenCanvas, undefined, CONFIG.CONFIDENCE_THRESHOLD);
                tf.engine().endScope();

                // Process raw detections into Pitch Data
                const frameData = analyzeDetections(detections, width, height);
                
                state.analysisData.push({
                    time: currentTime,
                    data: frameData
                });

                // Progress
                currentFrameIdx++;
                currentTime += (1/fps) * CONFIG.DETECTION_INTERVAL; // Skip frames logic

                const pct = Math.min(95, Math.floor((currentTime / state.videoDuration) * 100));
                updateProgress(10 + (pct * 0.85));

                if (currentFrameIdx % 10 === 0) {
                    log(`Processed ${currentFrameIdx * CONFIG.DETECTION_INTERVAL} frames...`, 'info');
                }
                
                // Safety break for very long videos in demo
                if (currentFrameIdx > 500) { 
                    log('Demo Limit Reached (500 frames)', 'info');
                    break; 
                }
            }

            log('Analysis Complete!', 'success');
            updateProgress(100);
            
            finishProcessing();
        }

        function analyzeDetections(detections, vWidth, vHeight) {
            const players = [];
            let ball = null;
            let confidenceSum = 0;
            let count = 0;

            detections.forEach(d => {
                const [x, y, w, h] = d.bbox;
                const centerX = x + w/2;
                // IMPORTANT: Use bottom of box (feet) for position, not center!
                const bottomY = y + h; 

                if (d.class === 'person') {
                    // 1. Map to 2D Pitch (Perspective Correction)
                    const pos = projectToPitch(centerX, bottomY, vWidth, vHeight);
                    
                    // 2. Team Detection (Color Sampling)
                    // Sample color from the center of the bounding box (torso area)
                    const colorData = els.hiddenCtx.getImageData(Math.floor(centerX), Math.floor(y + h/3), 1, 1).data;
                    const team = determineTeam(colorData);

                    players.push({
                        x: pos.x,
                        y: pos.y,
                        team: team,
                        bbox: d.bbox
                    });
                    
                    confidenceSum += d.score;
                    count++;
                } 
                else if (d.class === 'sports ball') {
                    const pos = projectToPitch(centerX, bottomY, vWidth, vHeight);
                    ball = { x: pos.x, y: pos.y };
                }
            });

            return {
                players,
                ball,
                avgConfidence: count > 0 ? (confidenceSum / count) : 0
            };
        }

        /**
         * Simulates a Perspective Transform (Trapezoid -> Rectangle)
         * This makes players far away (top of screen) map correctly compared to close ones.
         */
        function projectToPitch(x, y, width, height) {
            // Normalized coordinates (0 to 1)
            const nx = x / width;
            const ny = y / height;

            // Perspective distortion factor
            // The higher the Y (closer to bottom), the wider the field of view is usually
            // This is a heuristic approximation without matrix calibration
            
            // Pitch Canvas Dimensions
            const cw = els.canvas.width;
            const ch = els.canvas.height;
            const margin = 40;

            // Simple mapping (Vertical is linear, Horizontal is scaled by perspective)
            // We assume the camera is center-field.
            // Players at top (ny -> 0) are "squeezed" in X in video, so we expand them in 2D
            
            const pitchY = ny * (ch - margin*2) + margin;
            
            // Expansion factor: 1.0 at bottom, wider at top
            // This depends heavily on camera angle. Using linear for safety in this demo
            // but correctly using feet position fixes 80% of the "randomness"
            
            const pitchX = nx * (cw - margin*2) + margin;

            return { x: pitchX, y: pitchY };
        }

        /**
         * Simple logic to determine team based on pixel color brightness/hue
         */
        function determineTeam(pixel) {
            const [r, g, b] = pixel;
            const brightness = (r + g + b) / 3;

            // Logic: Dark Kit vs Light Kit vs Referee (Usually bright/distinct)
            // This is simplified. Real production code uses K-Means clustering.
            
            if (brightness > 180) return 'A'; // Light/White Kit
            if (brightness < 60) return 'B';  // Dark/Black Kit
            
            // Check for Red dominant
            if (r > g + 50 && r > b + 50) return 'B'; // Red Kit
            
            // Check for Blue dominant
            if (b > r + 30 && b > g + 30) return 'A'; // Blue Kit

            return 'A'; // Default
        }

        function finishProcessing() {
            els.process.style.display = 'none';
            els.dashboard.style.display = 'grid';
            
            // Reset video to start and unmute
            els.video.currentTime = 0;
            els.video.muted = false;
            
            // Enable Download
            document.getElementById('btnDownload').disabled = false;

            // Start Visualization Loop
            requestAnimationFrame(renderLoop);
        }

        function renderLoop() {
            if (els.video.paused || els.video.ended) {
                if (!els.video.paused) requestAnimationFrame(renderLoop);
                return;
            }

            const curTime = els.video.currentTime;
            
            // Find the closest analyzed frame data
            // We use findLast or simple iteration because data is sorted
            const frame = state.analysisData.reduce((prev, curr) => {
                return (Math.abs(curr.time - curTime) < Math.abs(prev.time - curTime) ? curr : prev);
            });

            if (frame) {
                drawPitchState(frame.data);
                updateStatsUI(frame.data, curTime);
            }

            requestAnimationFrame(renderLoop);
        }

        // If video is paused, we still want to draw the current frame if user seeks manually
        els.video.addEventListener('timeupdate', () => {
            if(els.video.paused) {
                const curTime = els.video.currentTime;
                const frame = state.analysisData.reduce((prev, curr) => {
                    return (Math.abs(curr.time - curTime) < Math.abs(prev.time - curTime) ? curr : prev);
                });
                if(frame) drawPitchState(frame.data);
            }
        });

        function drawPitchState(data) {
            const ctx = els.ctx;
            const w = els.canvas.width;
            const h = els.canvas.height;

            // 1. Draw Pitch (Static)
            ctx.fillStyle = CONFIG.PITCH_COLOR;
            ctx.fillRect(0, 0, w, h);

            // Lines
            ctx.strokeStyle = CONFIG.LINE_COLOR;
            ctx.lineWidth = 2;
            ctx.strokeRect(20, 20, w-40, h-40); // Touchline
            
            ctx.beginPath(); // Halfway
            ctx.moveTo(w/2, 20); ctx.lineTo(w/2, h-20);
            ctx.stroke();

            ctx.beginPath(); // Center Circle
            ctx.arc(w/2, h/2, 50, 0, Math.PI*2);
            ctx.stroke();

            // Boxes
            ctx.strokeRect(20, h/2 - 80, 60, 160); // Left Goal
            ctx.strokeRect(w-80, h/2 - 80, 60, 160); // Right Goal

            // 2. Draw Players
            data.players.forEach(p => {
                ctx.beginPath();
                ctx.arc(p.x, p.y, 10, 0, Math.PI*2);
                ctx.fillStyle = p.team === 'A' ? CONFIG.TEAM_A_COLOR : CONFIG.TEAM_B_COLOR;
                ctx.fill();
                ctx.lineWidth = 2;
                ctx.strokeStyle = '#fff';
                ctx.stroke();
                
                // Shadow
                ctx.beginPath();
                ctx.ellipse(p.x, p.y + 10, 8, 3, 0, 0, Math.PI*2);
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fill();
            });

            // 3. Draw Ball
            if (data.ball) {
                ctx.beginPath();
                ctx.arc(data.ball.x, data.ball.y, 6, 0, Math.PI*2);
                ctx.fillStyle = CONFIG.BALL_COLOR;
                ctx.fill();
            }
        }

        function updateStatsUI(data, time) {
            document.getElementById('statPlayers').innerText = data.players.length;
            document.getElementById('statConf').innerText = (data.avgConfidence * 100).toFixed(0) + '%';
            document.getElementById('statTime').innerText = time.toFixed(1) + 's';
        }

        async function downloadVideo() {
            const btn = document.getElementById('btnDownload');
            btn.innerText = 'Generating...';
            btn.disabled = true;

            const stream = els.canvas.captureStream(30);
            const recorder = new MediaRecorder(stream, { mimeType: 'video/webm' });
            const chunks = [];

            recorder.ondataavailable = e => chunks.push(e.data);
            recorder.onstop = () => {
                const blob = new Blob(chunks, { type: 'video/webm' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `pitch2d_analysis_${Date.now()}.webm`;
                a.click();
                btn.innerText = 'Download';
                btn.disabled = false;
            };

            recorder.start();
            
            // Play video from start to capture canvas sync
            els.video.currentTime = 0;
            els.video.play();
            
            els.video.onended = () => {
                recorder.stop();
                els.video.onended = null; // cleanup
            };
        }

        // Helpers
        function log(msg, type='info') {
            const div = document.createElement('div');
            div.className = `log-entry ${type}`;
            div.innerText = `[${new Date().toLocaleTimeString()}] ${msg}`;
            els.logs.appendChild(div);
            els.logs.scrollTop = els.logs.scrollHeight;
        }

        function updateProgress(val) {
            els.progress.style.width = `${val}%`;
        }
    </script>
</body>
</html>
